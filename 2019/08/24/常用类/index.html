<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>常用类 | Hai</title><meta name="description" content="常用类"><meta name="keywords" content><meta name="author" content="Hai"><meta name="copyright" content="Hai"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://yoursite.com/2019/08/24/常用类/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="常用类"><meta name="twitter:description" content="常用类"><meta name="twitter:image" content="http://yoursite.com/img/avatar.png"><meta property="og:type" content="article"><meta property="og:title" content="常用类"><meta property="og:url" content="http://yoursite.com/2019/08/24/常用类/"><meta property="og:site_name" content="Hai"><meta property="og:description" content="常用类"><meta property="og:image" content="http://yoursite.com/img/avatar.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="next" title="数组" href="http://yoursite.com/2019/07/17/数组/"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://jerryc.me/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天'

  
}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#常用类"><span class="toc-number">1.</span> <span class="toc-text">常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、包装类"><span class="toc-number">1.1.</span> <span class="toc-text">一、包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-包装类概念"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.包装类概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-包装类的使用"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.包装类的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-自动装箱和拆箱"><span class="toc-number">1.1.3.</span> <span class="toc-text">3.自动装箱和拆箱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-包装类的缓存问题"><span class="toc-number">1.1.4.</span> <span class="toc-text">4.包装类的缓存问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、String、StringBuilder和StringBuffer"><span class="toc-number">1.2.</span> <span class="toc-text">二、String、StringBuilder和StringBuffer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-String类"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.String类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-字符串相等判断"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.字符串相等判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-StringBuilder和StringBuffer"><span class="toc-number">1.2.3.</span> <span class="toc-text">3.StringBuilder和StringBuffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-可变与不可变字符串的使用"><span class="toc-number">1.2.4.</span> <span class="toc-text">4.可变与不可变字符串的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-三者区别"><span class="toc-number">1.2.5.</span> <span class="toc-text">5.三者区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、Date、DateFormat和Calendar"><span class="toc-number">1.3.</span> <span class="toc-text">三、Date、DateFormat和Calendar</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Date类"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.Date类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-DateFormat类和SimpleDateFormat类"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.DateFormat类和SimpleDateFormat类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Calendar类和GregorianCalendar类"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.Calendar类和GregorianCalendar类</span></a></li></ol></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/post.png)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">Hai</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><span class="pull-right menus"><div class="mobile_author_icon"><img class="lozad" data-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"><div class="mobile_author-info__description"></div></div><hr><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title"><div class="posttitle">常用类</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-08-24<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-08-27</time></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h1><h2 id="一、包装类"><a href="#一、包装类" class="headerlink" title="一、包装类"></a>一、包装类</h2><h3 id="1-包装类概念"><a href="#1-包装类概念" class="headerlink" title="1.包装类概念"></a>1.包装类概念</h3><p>&emsp;&emsp;Java是面向对象的语言，但并不是“纯面向对象”的，因为我们经常用到的基本数据类型就不是对象。但是我们在实际应用中经常需要将基本数据转化成对象，以便于操作。比如：将基本数据类型存储到Object[]数组或集合中的操作等等。<br>为了解决这个不足，Java在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八个和基本数据类型对应的类统称为包装类(Wrapper Class)。</p>
<p>&emsp;&emsp;包装类均位于java.lang包，八种包装类和基本数据类型的对应关系如表8-1所示：<br>    <table border="1" width="400" height="460" cellspacing="0" style="border-collapse: collapse;" cellpadding="10"><br>            <tr><th>基本数据类型</th><th>包装类</th></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>char</td><td>Character</td><br>            </tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><br>        </table><br><code>在这八个类名中，除了Integer和Character类以外，其它六个类的类名和基本数据类型一致，只是类名的第一个字母大写而已</code></p>
<h3 id="2-包装类的使用"><a href="#2-包装类的使用" class="headerlink" title="2.包装类的使用"></a>2.包装类的使用</h3><p>对于包装类来说，这些类的用途主要包含两种：</p>
<p>&emsp;&emsp;1. 作为和基本数据类型对应的类型存在，方便涉及到对象的操作，如Object[]、集合等的操作。</p>
<p>&emsp;&emsp;2. 包含每种基本数据类型的相关属性如最大值、最小值等，以及相关的操作方法(这些操作方法的作用是在基本数据类型、包装类对象、字符串之间提供相互之间的转化!)。</p>
<img src="/2019/08/24/常用类/p1.jpg" align="left">

<p>执行结果为：</p>
<img src="/2019/08/24/常用类/p2.jpg" align="left">

<h3 id="3-自动装箱和拆箱"><a href="#3-自动装箱和拆箱" class="headerlink" title="3.自动装箱和拆箱"></a>3.自动装箱和拆箱</h3><blockquote>
<p>自动装箱和拆箱就是将基本数据类型和包装类之间进行自动的互相转换。JDK1.5后，Java引入了自动装箱(autoboxing)/拆箱(unboxing)。</p>
</blockquote>
<p>自动装箱：基本类型的数据处于需要对象的环境中时，会自动转为“对象”。</p>
<p>自动拆箱：每当需要一个值时，对象会自动转成基本数据类型，没必要再去显式调用intValue()、doubleValue()等转型方法。</p>
<pre><code>Integer a = 234;//自动装箱。 Integer a = Integer.valueOf(234);
    int b = a;        //自动拆箱。 编译器会修改成： int b = a.intValue();

    Integer c = null;
    //if(c!=null) {//会出现空指针异常
        int d = c;        //自动拆箱:调用了:c.intVaule();
    //} </code></pre><h3 id="4-包装类的缓存问题"><a href="#4-包装类的缓存问题" class="headerlink" title="4.包装类的缓存问题"></a>4.包装类的缓存问题</h3><blockquote>
<p>&emsp;&emsp;整型、char类型所对应的包装类，在自动装箱时，对于-128~127之间的值会进行缓存处理，其目的是提高效率。</p>
</blockquote>
<p>&emsp;&emsp;缓存处理的原理为：如果数据在-128~127这个区间，那么在类加载时就已经为该区间的每个数值创建了对象，并将这256个对象存放到一个名为cache的数组中。每当自动装箱过程发生时(或者手动调用valueOf()时)，就会先判断数据是否在该区间，如果在则直接获取数组中对应的包装类对象的引用，如果不在该区间，则会通过new调用包装类的构造方法来创建对象。</p>
<pre><code>//缓存[-128,127]之间的数字//实际就是系统初始的时候创建了[-128,127]之间的一个cache数组，在
//范围内时直接从cache数组中取已经创好的对象，所以是同一个对象
Integer.valueOf(-128);
Integer in1 = -128;
Integer in2 = -128;
System.out.println(in1 == in2);//true 因为128在缓存范围内
System.out.println(in1.equals(in2));//true
System.out.println(&quot;---------------------&quot;);
Integer in3 = 1234;
Integer in4 = 1234;
System.out.println(in3 == in4);//false 因为1234不在缓存范围内
System.out.println(in3.equals(in4));//true</code></pre><h2 id="二、String、StringBuilder和StringBuffer"><a href="#二、String、StringBuilder和StringBuffer" class="headerlink" title="二、String、StringBuilder和StringBuffer"></a>二、String、StringBuilder和StringBuffer</h2><h3 id="1-String类"><a href="#1-String类" class="headerlink" title="1.String类"></a>1.String类</h3><blockquote>
<p>根据原码，字符串内容全部被存入value字符数组中，并用final修饰，即常量（只能被赋值一次），所以称String类是”不可变的字符序列”。</p>
</blockquote>
<p><code>String类是不可变的！！</code></p>
<img src="/2019/08/24/常用类/p3.jpg" align="left">

<pre><code>public class TestString02 {
    public static void main(String[] args) {
        String s1 = new String(&quot;abcdef&quot;);
            String s2 = s1.substring(2, 4);
            // 打印：ab199863
            System.out.println(Integer.toHexString(s1.hashCode()));
            // 打印：c61, 显然s1和s2不是同一个对象
            System.out.println(Integer.toHexString(s2.hashCode()));
    }
}</code></pre><p>String类的常用方法：</p>
<pre><code>public class TestString01 {
    public static void main(String[] args) {
        String s1 = &quot;core Java&quot;;
        String s2 = &quot;Core Java&quot;;
        System.out.println(s1.charAt(3));//提取下标为3的字符
        System.out.println(s2.length());//字符串的长度
        System.out.println(s1.equals(s2));//比较两个字符串是否相等
        System.out.println(s1.equalsIgnoreCase(s2));//比较两个字符串（忽略大小写）
        System.out.println(s1.indexOf(&quot;Java&quot;));//字符串s1中是否包含Java
        System.out.println(s1.indexOf(&quot;sea&quot;));//字符串s1中是否包含sea
        String str = s1.replace(&apos; &apos;, &apos;&amp;&apos;);//将s1中的空格替换成&amp;
        System.out.println(&quot;result is : &quot; + str);
        System.out.println(&quot;s1 : &quot;+s1);

        System.out.println(&quot;-----------------------------------------&quot;);

        String s = &quot;&quot;;
        System.out.println(&quot;s的地址&quot;+Integer.toHexString(s.hashCode()));
        String s3 = &quot;How are you?&quot;;
        System.out.println(s3.startsWith(&quot;How&quot;));//是否以How开头
        System.out.println(s3.endsWith(&quot;you&quot;));//是否以you结尾
        s = s3.substring(4);//提取子字符串：从下标为4的开始到字符串结尾为止
        System.out.println(s);
        System.out.println(&quot;s的地址&quot;+Integer.toHexString(s.hashCode()));
        s = s3.substring(4, 7);//提取子字符串：下标[4, 7) 不包括7
        System.out.println(s);
        System.out.println(&quot;s的地址&quot;+Integer.toHexString(s.hashCode()));//地址不同，不是同一个对象了
        s = s3.toLowerCase();//转小写
        System.out.println(s);
        s = s3.toUpperCase();//转大写
        System.out.println(s);
        String s4 = &quot;  How old are you!! &quot;;
        s = s4.trim();//去除字符串首尾的空格。注意：中间的空格不能去除
        System.out.println(s);
        System.out.println(s4);//因为String是不可变字符串，所以s4不变
    }
}</code></pre><img src="/2019/08/24/常用类/p4.jpg" align="left">

<h3 id="2-字符串相等判断"><a href="#2-字符串相等判断" class="headerlink" title="2.字符串相等判断"></a>2.字符串相等判断</h3><pre><code>public class TestStringEquals {
    public static void main(String[] args) {
        String s1 = &quot;长安十二时辰&quot;;
        String s2 = &quot;长安十二时辰&quot;;
        String s3 = new String(&quot;长安十二时辰&quot;);
        System.out.println(s1 == s2);//true 指向同一个字符串常量对象
        System.out.println(s1 == s3);//false s3是新创建的对象
        System.out.println(s1.equals(s3));//true 值内容相同
    }        
}</code></pre><img src="/2019/08/24/常用类/p5.jpg" align="center">

<h3 id="3-StringBuilder和StringBuffer"><a href="#3-StringBuilder和StringBuffer" class="headerlink" title="3.StringBuilder和StringBuffer"></a>3.StringBuilder和StringBuffer</h3><blockquote>
<p>两者的内部也是字符数组，但没有被final修饰，可以随时修改因此，StringBuilder和StringBuffer称之为”可变字符序列”。</p>
</blockquote>
<ol>
<li>StringBuffer 线程安全，做线程同步检查， 效率较低。</li>
<li>StringBuilder 线程不安全，不做线程同步检查，因此效率较高。 建议采用该类。</li>
</ol>
<p>两者用法基本相同：</p>
<pre><code>public class TestStringBuilder {
    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i &lt; 26; i++) {
            sb.append((char)(&apos;a&apos;+i));//追加单个字符
        }
        System.out.println(sb.toString());//转换成String输出
        sb.append(&quot;, helloworld!&quot;);//追加字符串
        System.out.println(sb.toString());

        System.out.println(&quot;-----------------------------&quot;);

        StringBuilder sb2 = new StringBuilder(&quot;拂衣去,深藏功与名&quot;);
        sb2.insert(0, &quot;了&quot;).insert(0, &quot;事&quot;);//插入字符串 //return的是this对象可链式调用
        System.out.println(sb2);
        sb2.delete(0, 2);//删除字符串[0,2)
        System.out.println(sb2);
        sb2.deleteCharAt(2);//删除某个字符串
        System.out.println(sb2);
        System.out.println(sb2.charAt(7));//获取某个字符
        System.out.println(sb2.reverse());//字符串逆序
    }
}</code></pre><img src="/2019/08/24/常用类/p6.jpg" align="left">

<h3 id="4-可变与不可变字符串的使用"><a href="#4-可变与不可变字符串的使用" class="headerlink" title="4.可变与不可变字符串的使用"></a>4.可变与不可变字符串的使用</h3><p>&emsp;&emsp;String一旦经过初始化后就不可变了。对String字符串的操作实际上是拷贝副本的操作，会导致大量副本字符串对象存留在内存中，降低效率，甚至造成服务器崩溃。相反，StringBuilder和StringBuffer类是对原字符串本身操作的，可以对字符串进行修改而不产生副本拷贝或者产生少量的副本。因此可以在循环中使用。</p>
<pre><code>public class TestStringBuilder02 {
    public static void main(String[] args) {
        /**使用String进行字符串的拼接*/
        String str8 = &quot;&quot;;
        //本质上使用StringBuilder拼接, 但是每次循环都会生成一个StringBuilder对象
        long num1 = Runtime.getRuntime().freeMemory();//获取系统剩余内存空间
        long time1 = System.currentTimeMillis();//获取系统的当前时间
        for (int i = 0; i &lt; 5000; i++) {
            str8 = str8 + i;//相当于产生了10000个对象
        }
        long num2 = Runtime.getRuntime().freeMemory();
        long time2 = System.currentTimeMillis();
        System.out.println(&quot;String占用内存 : &quot; + (num1 - num2));
        System.out.println(&quot;String占用时间 : &quot; + (time2 - time1));

        /**使用StringBuilder进行字符串的拼接*/
        StringBuilder sb1 = new StringBuilder(&quot;&quot;);
        long num3 = Runtime.getRuntime().freeMemory();
        long time3 = System.currentTimeMillis();
        for (int i = 0; i &lt; 5000; i++) {
            sb1.append(i);
        }
        long num4 = Runtime.getRuntime().freeMemory();
        long time4 = System.currentTimeMillis();
        System.out.println(&quot;StringBuilder占用内存 : &quot; + (num3 - num4));
        System.out.println(&quot;StringBuilder占用时间 : &quot; + (time4 - time3));
    }
}</code></pre><img src="/2019/08/24/常用类/p7.jpg" align="left">

<h3 id="5-三者区别"><a href="#5-三者区别" class="headerlink" title="5.三者区别"></a>5.三者区别</h3><ol>
<li>String：不可变字符序列。</li>
<li>StringBuffer：可变字符序列，并且线程安全，但是效率低。</li>
<li>StringBuilder：可变字符序列，线程不安全，但是效率高(一般用它)。</li>
</ol>
<h2 id="三、Date、DateFormat和Calendar"><a href="#三、Date、DateFormat和Calendar" class="headerlink" title="三、Date、DateFormat和Calendar"></a>三、Date、DateFormat和Calendar</h2><h3 id="1-Date类"><a href="#1-Date类" class="headerlink" title="1.Date类"></a>1.Date类</h3><blockquote>
<p>在标准Java类库中包含一个Date类。它的对象表示一个特定的瞬间，精确到毫秒。</p>
</blockquote>
<pre><code>public class TestDate {
    public static void main(String[] args) {
        //Date(long date) 分配 Date 对象并初始化此对象，以表示自从标准基准时间(称为“历元(epoch)”，即 1970 年 1 月 1 日 00:00:00 GMT)以来的指定毫秒数。
        Date d = new Date(2000);
        System.out.println(d);    
        System.out.println(d.getTime());

        //Date() 分配一个Date对象，并初始化此对象为系统当前的日期和时间，可以精确到毫秒
        Date d2 = new Date();
        System.out.println(d2.getTime());//转换为毫秒数
        System.out.println(d2.after(d));//是否在后
        System.out.println(d2.before(d));//是否在前

        //已废弃，以后遇到日期处理使用Canlendar日期类
        Date d3 = new Date(2020-1900,3,10);//2020/04/10
        System.out.println(d3);
    }
}</code></pre><p><code>JDK1.1之后，Date类的很多方法都过时了，日期操作一般使用Calendar类，而字符串的转化使用DateFormat类。</code></p>
<h3 id="2-DateFormat类和SimpleDateFormat类"><a href="#2-DateFormat类和SimpleDateFormat类" class="headerlink" title="2.DateFormat类和SimpleDateFormat类"></a>2.DateFormat类和SimpleDateFormat类</h3><blockquote>
<p>DateFormat类的作用:时间对象与字符串之间的相互转换。</p>
</blockquote>
<p><code>DateFormat是一个抽象类，一般使用它的的子类SimpleDateFormat类来实现</code></p>
<img src="/2019/08/24/常用类/p10.png" align="center">

<pre><code>public class TestDateFormat {
    public static void main(String[] args) throws ParseException {
        //把时间对象按照&quot;格式字符串指定格式&quot;转成相应的字符串
        //DateFormat df = new SimpleDateFormat(&quot;yyyy年MM月dd日 hh:mm:ss&quot;);
        DateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);//DateFormat是抽象类    
        String str = df.format(new Date());//可传毫秒
        System.out.println(str);

        //把字符串按照&quot;格式字符串指定的格式&quot;转成相应的时间对象
        DateFormat df2 = new SimpleDateFormat(&quot;yyyy年MM月dd天 hh时mm分ss秒&quot;);
        Date date = df2.parse(&quot;2019年08月27天 20时24分55秒&quot;);
        System.out.println(date);

        //测试其他格式的字符。比如：利用D,获取本时间对象是所处年份的第几天。
        DateFormat df3 = new SimpleDateFormat(&quot;D&quot;);
        String str3 = df3.format(new Date());
        System.out.println(str3);
    }
}</code></pre><p>执行结果如下：<br><img src="/2019/08/24/常用类/p8.jpg" align="center"></p>
<h3 id="3-Calendar类和GregorianCalendar类"><a href="#3-Calendar类和GregorianCalendar类" class="headerlink" title="3.Calendar类和GregorianCalendar类"></a>3.Calendar类和GregorianCalendar类</h3><blockquote>
<p>Calendar 类是一个抽象类，为我们提供了关于日期计算的相关功能，比如：年、月、日、时、分、秒的展示和计算。</p>
</blockquote>
<blockquote>
<p>GregorianCalendar 是 Calendar 的一个具体子类，提供了世界上大多数国家/地区使用的标准日历系统。</p>
</blockquote>
<p><code>月份0~11，周日-周六1~7</code></p>
<pre><code>public class TestCanlendar02 {
    public static void main(String[] args) {
        // 得到相关日期元素
        GregorianCalendar calendar = new GregorianCalendar(2999, 10, 9, 22, 10, 50);
        int year = calendar.get(Calendar.YEAR); // 打印：1999
        int month = calendar.get(Calendar.MONTH); // 打印：10
        int day = calendar.get(Calendar.DAY_OF_MONTH); // 打印：9
        int day2 = calendar.get(Calendar.DATE); // 打印：9
        // 日：Calendar.DATE和Calendar.DAY_OF_MONTH同义
        int date = calendar.get(Calendar.DAY_OF_WEEK); // 打印：3
        // 星期几 这里是：1-7.周日是1，周一是2，。。。周六是7
        System.out.println(year);
        System.out.println(month);
        System.out.println(day);
        System.out.println(day2);
        System.out.println(date);
        // 设置日期
        GregorianCalendar calendar2 = new GregorianCalendar();
        calendar2.set(Calendar.YEAR, 2999);
        calendar2.set(Calendar.MONTH, Calendar.FEBRUARY); // 月份数：0-11
        calendar2.set(Calendar.DATE, 3);
        calendar2.set(Calendar.HOUR_OF_DAY, 10);
        calendar2.set(Calendar.MINUTE, 20);
        calendar2.set(Calendar.SECOND, 23);
        printCalendar(calendar2);
        // 日期计算
        GregorianCalendar calendar3 = new GregorianCalendar(2999, 10, 9, 22, 10, 50);
        calendar3.add(Calendar.MONTH, -7); // 月份减7
        calendar3.add(Calendar.DATE, 7); // 增加7天
        printCalendar(calendar3);
        // 日历对象和时间对象转化
        Date d = calendar3.getTime();
        GregorianCalendar calendar4 = new GregorianCalendar();
        calendar4.setTime(new Date());
        long g = System.currentTimeMillis();
    }

    static void printCalendar(Calendar calendar) {
        int year = calendar.get(Calendar.YEAR);
        int month = calendar.get(Calendar.MONTH) + 1;
        int day = calendar.get(Calendar.DAY_OF_MONTH);
        int date = calendar.get(Calendar.DAY_OF_WEEK) - 1; // 星期几
        String week = &quot;&quot; + ((date == 0) ? &quot;日&quot; : date);
        int hour = calendar.get(Calendar.HOUR);
        int minute = calendar.get(Calendar.MINUTE);
        int second = calendar.get(Calendar.SECOND);
        System.out.printf(&quot;%d年%d月%d日,星期%s %d:%d:%d\n&quot;, year, month, day, week, hour, minute, second);
    }

}</code></pre><img src="/2019/08/24/常用类/p9.jpg" align="center"></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Hai</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/08/24/常用类/">http://yoursite.com/2019/08/24/常用类/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">Hai</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-buttom"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" data-src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" data-src="/img/alipay.jpg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2019/07/17/数组/"><img class="next_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>数组</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"></div><div class="clear_both"></div></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2019 By Hai</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><i class="fa fa-book" id="readmode" title="阅读模式"> </i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">簡</a><i class="fa fa-moon-o nightshift" id="nightshift" title="夜间模式"></i></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/nightshift.js"></script><script id="ribbon" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/js/piao.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script></body></html>