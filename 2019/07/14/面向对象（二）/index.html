<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>面向对象（二） | Hai</title><meta name="description" content="面向对象（二）"><meta name="keywords" content><meta name="author" content="Hai"><meta name="copyright" content="Hai"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://yoursite.com/2019/07/14/面向对象（二）/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="面向对象（二）"><meta name="twitter:description" content="面向对象（二）"><meta name="twitter:image" content="http://yoursite.com/img/avatar.png"><meta property="og:type" content="article"><meta property="og:title" content="面向对象（二）"><meta property="og:url" content="http://yoursite.com/2019/07/14/面向对象（二）/"><meta property="og:site_name" content="Hai"><meta property="og:description" content="面向对象（二）"><meta property="og:image" content="http://yoursite.com/img/avatar.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="面向对象（三）" href="http://yoursite.com/2019/07/14/面向对象（三）/"><link rel="next" title="面向对象（一）" href="http://yoursite.com/2019/07/13/面向对象（一）/"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://jerryc.me/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天'

  
}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#面向对象（二）"><span class="toc-number">1.</span> <span class="toc-text">面向对象（二）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、封装"><span class="toc-number">1.1.</span> <span class="toc-text">一、封装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-特点"><span class="toc-number">1.1.1.</span> <span class="toc-text">(1) 特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-访问控制符"><span class="toc-number">1.1.2.</span> <span class="toc-text">(2) 访问控制符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-package（包）"><span class="toc-number">1.1.3.</span> <span class="toc-text">(3) package（包）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、继承"><span class="toc-number">1.2.</span> <span class="toc-text">二、继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-继承的利弊"><span class="toc-number">1.2.1.</span> <span class="toc-text">(2) 继承的利弊</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-继承的特点"><span class="toc-number">1.2.2.</span> <span class="toc-text">(3) 继承的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-this与super"><span class="toc-number">1.2.3.</span> <span class="toc-text">(4) this与super</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-方法重写-overwrite-——两同两小一大"><span class="toc-number">1.2.4.</span> <span class="toc-text">(5) 方法重写(overwrite)——两同两小一大</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、多态"><span class="toc-number">1.3.</span> <span class="toc-text">三、多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-特点-1"><span class="toc-number">1.3.1.</span> <span class="toc-text">(1) 特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-必要条件"><span class="toc-number">1.3.2.</span> <span class="toc-text">(2) 必要条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-多态中的访问特点之成员变量"><span class="toc-number">1.3.3.</span> <span class="toc-text">(3) 多态中的访问特点之成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-多态中的访问特点之方法"><span class="toc-number">1.3.4.</span> <span class="toc-text">(4) 多态中的访问特点之方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-多态中的向上转型和向下转型"><span class="toc-number">1.3.5.</span> <span class="toc-text">(5) 多态中的向上转型和向下转型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-多态的利弊"><span class="toc-number">1.3.6.</span> <span class="toc-text">(6) 多态的利弊</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-instanceof运算符"><span class="toc-number">1.3.7.</span> <span class="toc-text">(7) instanceof运算符</span></a></li></ol></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/post.png)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">Hai</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><span class="pull-right menus"><div class="mobile_author_icon"><img class="lozad" data-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"><div class="mobile_author-info__description"></div></div><hr><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title"><div class="posttitle">面向对象（二）</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-07-14<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-07-14</time></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="面向对象（二）"><a href="#面向对象（二）" class="headerlink" title="面向对象（二）"></a>面向对象（二）</h1><h2 id="一、封装"><a href="#一、封装" class="headerlink" title="一、封装"></a>一、封装</h2><blockquote>
<p>将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，而是通过该类所提供的方法来实现对内部信息的操作和访问</p>
</blockquote>
<h3 id="1-特点"><a href="#1-特点" class="headerlink" title="(1) 特点"></a>(1) 特点</h3><p>①. 良好的封装能够减少耦合<br>②. 类内部的结构可以自由修改<br>③. 可以对成员变量进行更精确的控制<br>④. 隐藏信息，实现细节</p>
<h3 id="2-访问控制符"><a href="#2-访问控制符" class="headerlink" title="(2) 访问控制符"></a>(2) 访问控制符</h3><blockquote>
<p>Java提供了private、protected、public和不加任何访问控制符(default)4个访问控制级别</p>
</blockquote>
<img src="/2019/07/14/面向对象（二）/p1.jpg" align="left">
&emsp;&emsp;private(当前类访问权限)：如果用于修饰类里的一个成员（包括成员变量、方法和构造器等），该成员只能在当前类的内部被访问。
&emsp;&emsp;default(包（package）访问权限)：如果用于修饰类里的一个成员（包括成员变量、方法和构造器等）或者一个外部类，该成员可以被相同包下的其他类访问。
&emsp;&emsp;protected（子类访问权限）：如果用于修饰一个成员（包括成员变量、方法和构造器等），该成员既可以被同一个包中的其他类访问，也可以被不同包中的子类访问。在通常情况下，如果使用protected来修饰一个方法，通常是希望其子类来重写这个方法。
&emsp;&emsp;public（公共访问权限）：如果用于修饰一个成员（包括成员变量、方法和构造器等）或者一个外部类，该成员或外部类就可以被所有类访问，不管访问类和被访问类是否处于同一个包中，是否具有父子继承关系。

<p>访问控制级别</p>
<table bgcolor="black" align="center" cellspacing="2" width="600" height="300"><tr bgcolor="white"><th></th><th>private</th><th>default</th><th>protected</th><th>public</th></tr><tr bgcolor="white"><td>同一个类</td><td>✔</td><td>✔</td><td>✔</td><td>✔</td></tr><tr bgcolor="white"><td>同一个包</td><td></td><td>✔</td><td>✔</td><td>✔</td></tr><tr bgcolor="white"><td>子类中</td><td></td><td></td><td>✔</td><td>✔</td></tr><tr bgcolor="white"><td>全局范围</td><td></td><td></td><td></td><td>✔</td></tr></table>

<h3 id="3-package（包）"><a href="#3-package（包）" class="headerlink" title="(3) package（包）"></a>(3) package（包）</h3><blockquote>
<p>包这种机制是为了防止命名冲突，访问控制，提供搜索和定位类、接口、枚举和注释等。</p>
</blockquote>
<p>作用：<br>① 把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。<br>② 如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。<br>③ 包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类</p>
<p>语法：package 包名;</p>
<p>一般在Java源程序的第一个非注释行（Java源文件的第一行）</p>
<p>导包操作：import 包名.子包名.类名（导入某个类）<br>&emsp;&emsp;&emsp;&emsp;&emsp;Import 包名.子包名.*（导入某个包下的所有类）</p>
<p>• 封装要点：<br>• 类的属性的处理:<br>&emsp;&emsp;• 一般使用private.  (除非本属性确定会让子类继承)<br>&emsp;&emsp;• 提供相应的get/set方法来访问相关属性. 这些方法通常是public，从而提供对属性的读取操作。<br>&emsp;&emsp;（注意：boolean变量的get方法是用：is开头!）<br>• 一些只用于本类的辅助性方法可以用private<br> • 希望其他类调用的方法用public</p>
<h2 id="二、继承"><a href="#二、继承" class="headerlink" title="二、继承"></a>二、继承</h2><blockquote>
<p>继承机制是面向对象程序设计为了能够提高软件开发效率的技术，继承机制允许和鼓励类的重用，子类既具有自己新定义的属性和行为，又具有从父类继承下来的属性和行为。</p>
</blockquote>
<p>Java的继承是通过extends关键字来实现的，实现继承的类被称为子类，被继承的类被称为父类。</p>
<p>###(1) 语法</p>
<pre><code>&amp;emsp;&amp;emsp;修饰符 class 父类{
&amp;emsp;&amp;emsp;//父类类结构部分
&amp;emsp;&amp;emsp;}

&amp;emsp;&amp;emsp;修饰符 class 子类 extends 父类{
&amp;emsp;&amp;emsp;//子类类结构部分
&amp;emsp;&amp;emsp;}</code></pre><img src="/2019/07/14/面向对象（二）/p2.jpg" align="left">

<h3 id="2-继承的利弊"><a href="#2-继承的利弊" class="headerlink" title="(2) 继承的利弊"></a>(2) 继承的利弊</h3><p>继承的好处:<br>&emsp;&emsp;① 提高了代码的复用性<br>&emsp;&emsp;② 提高了代码的维护性<br>&emsp;&emsp;③ 让类与类之间产生了关系，是多态的前提<br>继承的弊端:<br>&emsp;&emsp;① 类的耦合性增强了。</p>
<p><code>开发的原则：高内聚，低耦合。</code><br><code>* 耦合：类与类的关系</code><br><code>* 内聚：就是自己完成某件事情的能力</code></p>
<h3 id="3-继承的特点"><a href="#3-继承的特点" class="headerlink" title="(3) 继承的特点"></a>(3) 继承的特点</h3><p>① Java只支持单继承（一个儿子只能有一个老爸）<br>② Java支持多层继承<br> <img src="/2019/07/14/面向对象（二）/p3.jpg" align="left"><br>③ 子类可以继承父类非 private 的属性、方法，但不能继承父类的构造器，（可以通过super关键字去访问父类的构造器）。子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。子类可以用自己的方式实现父类的方法，但父类不能实现子类特有的方法。<br>④ 使用原则：符合”is-a”原则(D is a B——D是B的子类)</p>
<h3 id="4-this与super"><a href="#4-this与super" class="headerlink" title="(4) this与super"></a>(4) this与super</h3><blockquote>
<p>this:代表当前对象的引用，谁调用this，就代表谁<br>super:代表当前对象的父类的引用</p>
</blockquote>
<p>this和super的使用区别<br>① 调用成员变量<br>&emsp;&emsp;this.成员变量 调用本类的成员变量,也可以调用父类的成员变量（其实也是本类的成员变量，只不过是从父类继承过来的）<br>        super.成员变量 调用父类的成员变量<br>② 调用构造方法<br>&emsp;&emsp;this(…)    调用本类的构造方法<br>&emsp;&emsp;super(…)    调用父类的构造方法<br>③ 调用成员方法<br>&emsp;&emsp;this.成员方法 调用本类的成员方法,也可以调用父类的方法（其实也是本类的成员方法，只不过是从父类继承过来的）<br>&emsp;&emsp;super.成员方法 调用父类的成员方法</p>
<p><code>注意：
子类所有构造器默认都会访问父类中无参构造(super()语句是隐藏的)，因为子类会继承父类的数据，还会有可能使用父类的数据。所以子类初始化前需要先完成父类数据的初始化。</code></p>
<p>如果父类没有无参构造，可通过this或super解决，但this(…)或super(…)必须出现构造器的第一条语句中，且二者不能共存。</p>
<img src="/2019/07/14/面向对象（二）/p4.jpg" align="left">
<img src="/2019/07/14/面向对象（二）/p5.jpg" align="left">
<img src="/2019/07/14/面向对象（二）/p6.jpg" align="left">

<p><code>总结：父类最好手动的添加无参构造，如果需要调用父类的东西，再去通过super去调用。</code></p>
<h3 id="5-方法重写-overwrite-——两同两小一大"><a href="#5-方法重写-overwrite-——两同两小一大" class="headerlink" title="(5) 方法重写(overwrite)——两同两小一大"></a>(5) 方法重写(overwrite)——两同两小一大</h3><p>两同：子类与父类中，方法名相同、形参列表相同。<br>两小：子类的方法返回值类型比父类方法返回值类型更小或相等<br>&emsp;&emsp;&emsp;子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等。<br>一大：子类方法的访问权限比父类方法的访问权限更大或相等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Curr&#123;</span><br><span class="line">    public void fun(int i) &#123;</span><br><span class="line">        System.out.println(&quot;int&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void fun(int i,String s)&#123;</span><br><span class="line">        System.out.println(&quot;int,String&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void fun(String s,int i)&#123;</span><br><span class="line">        System.out.println(&quot;String,int&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class override&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Curr curr = new Curr();</span><br><span class="line">        curr.fun(0);</span><br><span class="line">        curr.fun(0, &quot;&quot;);</span><br><span class="line">        curr.fun(&quot;&quot;, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用：当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法。这样，即沿袭了父类的功能，又定义了子类特有的内容。<br><code>注意：父类中私有方法不能被重写
      子类重写父类方法时，访问权限不能更低</code></p>
<h2 id="三、多态"><a href="#三、多态" class="headerlink" title="三、多态"></a>三、多态</h2><blockquote>
<p>同一个行为具有多个不同表现形式或形态的能力</p>
</blockquote>
<img src="/2019/07/14/面向对象（二）/p7.jpg" align="left">
&emsp;&emsp;Java引用变量有两种类型：编译时类型（左边），运行时类型（右边）。如果编译时类型与运行时类型不一致，就会出现多态。

<h3 id="1-特点-1"><a href="#1-特点-1" class="headerlink" title="(1) 特点"></a>(1) 特点</h3><p>①    消除类型之间的耦合关系<br>②    可替换性<br>③    可扩充性<br>④    接口性<br>⑤    灵活性<br>⑥    简化性</p>
<h3 id="2-必要条件"><a href="#2-必要条件" class="headerlink" title="(2) 必要条件"></a>(2) 必要条件</h3><p>①    要有继承关系。<br>②    要有方法重写。<br>③    要有父类引用指向子类对象<br><img src="/2019/07/14/面向对象（二）/p8.jpg" align="left"><br><img src="/2019/07/14/面向对象（二）/p9.jpg" align="left"></p>
<h3 id="3-多态中的访问特点之成员变量"><a href="#3-多态中的访问特点之成员变量" class="headerlink" title="(3) 多态中的访问特点之成员变量"></a>(3) 多态中的访问特点之成员变量</h3><p>编译看左边(父类)，运行看左边(父类)<br><code>通过引用变量来访问其包含的实例变量时，系统总是试图访问它编译时类型所定义的成员变量，而不是它运行时类型所定义的成员变量。（成员变量时前期编译时绑定的）</code><br><img src="/2019/07/14/面向对象（二）/p12.jpg" align="left"></p>
<h3 id="4-多态中的访问特点之方法"><a href="#4-多态中的访问特点之方法" class="headerlink" title="(4) 多态中的访问特点之方法"></a>(4) 多态中的访问特点之方法</h3><p>编译看左边(父类)，运行看右边(子类)<br>编译时如果不写对应的方法会编译会报错，引用变量在编译阶段只能调用其编译类型所具有的方法，但运行时则执行它运行类型所具有的方法。（普通方法是动态绑定）<br><img src="/2019/07/14/面向对象（二）/p13.jpg" align="left"></p>
<img src="/2019/07/14/面向对象（二）/p10.jpg" align="left">
<img src="/2019/07/14/面向对象（二）/p11.jpg" align="left">

<h3 id="5-多态中的向上转型和向下转型"><a href="#5-多态中的向上转型和向下转型" class="headerlink" title="(5) 多态中的向上转型和向下转型"></a>(5) 多态中的向上转型和向下转型</h3><p>基本数据类型只能在数值类型（整数型、字符型和浮点型）之间进行<br>引用数据类型之间只能在具有继承关系的两个类型之间进行，如果两个没有任何继承关系的类型，无法进行类型转换。如果试图把一个父类实例转换成子类类型，则这个对象必须实际上是子类实例，否则会出现ClassCastException异常。</p>
<h3 id="6-多态的利弊"><a href="#6-多态的利弊" class="headerlink" title="(6) 多态的利弊"></a>(6) 多态的利弊</h3><p>好处：<br>提高代码的维护(继承保证)——父类有变化子类也随之变化<br>提高代码的扩展性(多态保证)<br>弊端：<br>不能使用子类的特有属性</p>
<h3 id="7-instanceof运算符"><a href="#7-instanceof运算符" class="headerlink" title="(7) instanceof运算符"></a>(7) instanceof运算符</h3><p>语法：对象名 instanceof 类<br>&emsp;&emsp;&emsp;B b = new B();<br>在运行时指出对象是否是特定类的一个实例。instanceof通过返回一个布尔值来指出，这个对象是否是这个特定类或者是它的子类的一个实例。<br><code>为了防止ClassCastException，利用instanceof判断前面的引用是否属于后面的数据类型，如果是可以利用强制类型转换</code><br>运算符是双目运算符,左面的操作元是一个对象,右面是一个类.当左面的对象是右面的类创建的对象时,该运算符运算的结果是true,否则是false<br><img src="/2019/07/14/面向对象（二）/p14.jpg" align="left"></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Hai</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/07/14/面向对象（二）/">http://yoursite.com/2019/07/14/面向对象（二）/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">Hai</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-buttom"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" data-src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" data-src="/img/alipay.jpg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2019/07/14/面向对象（三）/"><img class="prev_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>面向对象（三）</span></div></a></div><div class="next-post pull-right"><a href="/2019/07/13/面向对象（一）/"><img class="next_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>面向对象（一）</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"></div><div class="clear_both"></div></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By Hai</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><i class="fa fa-book" id="readmode" title="阅读模式"> </i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">簡</a><i class="fa fa-moon-o nightshift" id="nightshift" title="夜间模式"></i></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/nightshift.js"></script><script id="ribbon" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/js/piao.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script></body></html>