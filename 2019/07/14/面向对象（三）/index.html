<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>面向对象（三） | Hai</title><meta name="description" content="面向对象（三）"><meta name="keywords" content><meta name="author" content="Hai"><meta name="copyright" content="Hai"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://yoursite.com/2019/07/14/面向对象（三）/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="面向对象（三）"><meta name="twitter:description" content="面向对象（三）"><meta name="twitter:image" content="http://yoursite.com/img/avatar.png"><meta property="og:type" content="article"><meta property="og:title" content="面向对象（三）"><meta property="og:url" content="http://yoursite.com/2019/07/14/面向对象（三）/"><meta property="og:site_name" content="Hai"><meta property="og:description" content="面向对象（三）"><meta property="og:image" content="http://yoursite.com/img/avatar.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="static与final关键字" href="http://yoursite.com/2019/07/14/static与final关键字/"><link rel="next" title="面向对象（二）" href="http://yoursite.com/2019/07/14/面向对象（二）/"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://jerryc.me/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天'

  
}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#面向对象（三）"><span class="toc-number">1.</span> <span class="toc-text">面向对象（三）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#抽象类"><span class="toc-number">1.1.</span> <span class="toc-text">抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-抽象方法和抽象类规则"><span class="toc-number">1.1.1.</span> <span class="toc-text">(1) 抽象方法和抽象类规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-抽象类的子类"><span class="toc-number">1.1.2.</span> <span class="toc-text">(3) 抽象类的子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-抽象类的成员特点"><span class="toc-number">1.1.3.</span> <span class="toc-text">(4) 抽象类的成员特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-abstract关键字"><span class="toc-number">1.1.4.</span> <span class="toc-text">(5) abstract关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、接口"><span class="toc-number">1.2.</span> <span class="toc-text">二、接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-接口的定义"><span class="toc-number">1.2.1.</span> <span class="toc-text">1. 接口的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-接口的使用"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. 接口的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-特点："><span class="toc-number">1.2.3.</span> <span class="toc-text">3. 特点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-类与类、接口与接口、类与接口的关系"><span class="toc-number">1.2.4.</span> <span class="toc-text">4. 类与类、接口与接口、类与接口的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-抽象类与接口的区别"><span class="toc-number">1.2.5.</span> <span class="toc-text">5. 抽象类与接口的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、内部类"><span class="toc-number">1.3.</span> <span class="toc-text">三、内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-特点"><span class="toc-number">1.3.1.</span> <span class="toc-text">(1) 特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-静态成员内部类（被static修饰的内部类）"><span class="toc-number">1.3.2.</span> <span class="toc-text">(3) 静态成员内部类（被static修饰的内部类）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-局部内部类（在外部类方法中定义类）——只在方法里有效"><span class="toc-number">1.3.3.</span> <span class="toc-text">(4) 局部内部类（在外部类方法中定义类）——只在方法里有效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-匿名内部类"><span class="toc-number">1.3.4.</span> <span class="toc-text">(5) 匿名内部类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、初始化块（代码块）"><span class="toc-number">1.4.</span> <span class="toc-text">四、初始化块（代码块）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-语法："><span class="toc-number">1.4.1.</span> <span class="toc-text">(1)    语法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-作用"><span class="toc-number">1.4.2.</span> <span class="toc-text">(2)    作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-被static修饰的静态代码块"><span class="toc-number">1.4.3.</span> <span class="toc-text">(3)    被static修饰的静态代码块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、类中所有成员的执行顺序"><span class="toc-number">1.5.</span> <span class="toc-text">五、类中所有成员的执行顺序</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/post.png)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">Hai</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><span class="pull-right menus"><div class="mobile_author_icon"><img class="lozad" data-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"><div class="mobile_author-info__description"></div></div><hr><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title"><div class="posttitle">面向对象（三）</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-07-14<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-07-14</time></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="面向对象（三）"><a href="#面向对象（三）" class="headerlink" title="面向对象（三）"></a>面向对象（三）</h1><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>&emsp;&emsp;假如定义一个shape类，这个类提供一个计算周长的方法，但不同Shape子类对周长的计算方法都不一样。既然Shape类不知道如何实现计算周长的方法，干脆就不管了。但如果利用多态来对Shape引用变量指向子类对象方式，Shape变量无法调用计算周长的方法，必须将其强制类型转换为子类类型才可调用，这就降低了程序的灵活性。<br>&emsp;&emsp;Java提供了抽象方法让类包含某个方法又不需要提供方法具体实现。<br>抽象方法：方法必须使用abstract修饰符来修饰，抽象方法只能存在与抽象类中，但抽象类可以没有抽象方法。</p>
<h3 id="1-抽象方法和抽象类规则"><a href="#1-抽象方法和抽象类规则" class="headerlink" title="(1) 抽象方法和抽象类规则"></a>(1) 抽象方法和抽象类规则</h3><p>(1) 抽象类必须使用abstract修饰符修饰，抽象方法也必须使用abstract修饰符修饰，<code>抽象方法不能有方法体。</code><br>(2) <code>抽象类不能被实例化。</code>无法使用new关键字来调用抽象类的构造器创建抽象类的对象。<br>(3) 抽象类可以包含成员变量、方法（普通方法和抽象方法都可以）、构造器、初始化块、内部类（接口、枚举）。<code>抽象类的构造器不能用于创建对象，用于被其子类调用。</code><br>(4) 有抽象方法的类一定是抽象类。</p>
<p>###(2) 抽象类如何被实例化<br>以多态的形式，由具体的子类实例化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">abstract class Animal&#123;</span><br><span class="line">	public abstract void eat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat extends Animal&#123;</span><br><span class="line">	public void eat()&#123;</span><br><span class="line">			System.out.println(&quot;猫吃鱼&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">	//Animal a = new Animal(); //错误,Animal是抽象的，无法实例化</span><br><span class="line">	Animal a = new Cat();//父类引用指向子类对象</span><br><span class="line">	a.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-抽象类的子类"><a href="#3-抽象类的子类" class="headerlink" title="(3) 抽象类的子类"></a>(3) 抽象类的子类</h3><p>1 .    要么也是抽象类<br>2 .    要么重写父类中所有抽象方法</p>
<h3 id="4-抽象类的成员特点"><a href="#4-抽象类的成员特点" class="headerlink" title="(4) 抽象类的成员特点"></a>(4) 抽象类的成员特点</h3><p>成员变量：既可以是变量，也可以是常量。<br>构造方法：用于子类访问父类数据的初始化。<br>成员方法：既可以是抽象的，也可以是非抽象的<br>抽象方法:&emsp;强制要求子类做的事情。<br>非抽象方法:  子类继承的事情，提高代码复用性</p>
<h3 id="5-abstract关键字"><a href="#5-abstract关键字" class="headerlink" title="(5) abstract关键字"></a>(5) abstract关键字</h3><p>不能与static同时存在，被abstract修饰的方法没有方法体，被static修饰的可以用类名.调用,但是类名.调用抽象方法是没有意义的<br>不能与final同时存在，被abstract修饰的方法强制子类重写，被final修饰的不让子类重写,所以两者互相矛盾<br>不能与private同时存在，被abstract修饰的是为了让子类继承并强制重写，被private修饰不让子类访问,所以两者互相矛盾的</p>
<h2 id="二、接口"><a href="#二、接口" class="headerlink" title="二、接口"></a>二、接口</h2><p>&emsp;&emsp;抽象类是从多个类抽象出来的模板，但抽象类允许存在普通方法抽象得不彻底。为了抽象彻底，提炼出一种更加抽象彻底的“抽象类”——接口。<code>接口里不能包含普通方法，接口里的所有方法都是抽象方法。（Java 8对接口进行了改进，允许接口中定义默认方法——可以提供方法实现）</code></p>
<h3 id="1-接口的定义"><a href="#1-接口的定义" class="headerlink" title="1. 接口的定义"></a>1. 接口的定义</h3><pre><code>语法：
[修饰符] interface接口名 [extends 父接口1，父接口2...]{
定义零到多个常量
定义零到多个抽象方法
定义零到多个内部类、接口、枚举
定义领导多个默认方法或类方法
}</code></pre><p>修饰符：public或缺省<br>接口名：符合标识符规则<br>继承：继承多个父接口，但不能继承类</p>
<p><code>注意：
1)可以包含成员变量（只能是静态常量）——系统会默认增加 public static final三个关键字</code></p>
<pre><code>Interface Inter{
    public static final int num = 10;
}</code></pre><p>因为num的值不能再修改，因此系统默认final修饰num成员变量</p>
<pre><code>class Demo implements Inter{
    public void print(){
    //num = 20;
    System.out.println(num);
    }
}</code></pre><p>可以通过类名.成员变量名输出，因此系统默认public 和static修饰num成员变量</p>
<pre><code>System.out.println(Inter.num);</code></pre><p>2)方法（抽象实例方法、类方法或默认方法）、内部类（包括内部接口、枚举）<br><img src="/2019/07/14/面向对象（三）/p1.jpg" align="left"></p>
<p><code>不能包含构造器和初始化块。</code><br><code>接口中的抽象方法系统会默认public和abstract，当实现类重写抽象方法时，需要注意访问权限必须是public</code></p>
<h3 id="2-接口的使用"><a href="#2-接口的使用" class="headerlink" title="2. 接口的使用"></a>2. 接口的使用</h3><p>通过implements关键实现接口</p>
<pre><code>语法：[修饰符] class 类名 [extends 父类] implements 接口1 [，接口2 ...]{
    类体部分
}</code></pre><p><code>注意：某个类实现了接口，该类需要把接口中的抽象方法全部重写</code></p>
<h3 id="3-特点："><a href="#3-特点：" class="headerlink" title="3. 特点："></a>3. 特点：</h3><p>接口不能被实例化——多态方式实例化</p>
<h3 id="4-类与类、接口与接口、类与接口的关系"><a href="#4-类与类、接口与接口、类与接口的关系" class="headerlink" title="4. 类与类、接口与接口、类与接口的关系"></a>4. 类与类、接口与接口、类与接口的关系</h3><p>类与类：继承关系，只能单继承，可以多层继承</p>
<p>接口与接口：继承关系,可以单继承,也可以多继承</p>
<p>类与接口：实现关系,可以单实现,也可以多实现。<br>&emsp;&emsp;&emsp;&emsp;&emsp;并且还可以在继承一个类的同时实现多个接口</p>
<h3 id="5-抽象类与接口的区别"><a href="#5-抽象类与接口的区别" class="headerlink" title="5. 抽象类与接口的区别"></a>5. 抽象类与接口的区别</h3><p>(1) 成员区别<br>    抽象类：<br>&emsp;&emsp;成员变量：可以变量，也可以常量<br>&emsp;&emsp;构造方法：有<br>&emsp;&emsp;成员方法：可以抽象，也可以非抽象<br>    接口：<br>&emsp;&emsp;成员变量：只可以常量<br>&emsp;&emsp;构造方法：无<br>&emsp;&emsp;成员方法：只可以抽象</p>
<p>(2) 关系区别<br>    类与类<br>&emsp;&emsp;继承，单继承<br>    类与接口<br>&emsp;&emsp;实现，单实现，多实现<br>    接口与接口<br>&emsp;&emsp;继承，单继承，多继承</p>
<h2 id="三、内部类"><a href="#三、内部类" class="headerlink" title="三、内部类"></a>三、内部类</h2><blockquote>
<p>在类中定义的类称为内部类</p>
</blockquote>
<h3 id="1-特点"><a href="#1-特点" class="headerlink" title="(1) 特点"></a>(1) 特点</h3><p>①    内部类可以直接访问外部类的成员，包括私有<br>②    外部类要访问内部类的成员，必须创建内部类的对象<br>&emsp;&nbsp;外部类类名.内部类类名 对象名 = 外部类对象.内部类对象；<br><img src="/2019/07/14/面向对象（三）/p2.jpg" align="left"></p>
<p>###(2) 成员内部类私有使用（内部类被private修饰）<br><img src="/2019/07/14/面向对象（三）/p3.jpg" align="left"><br>注意：私有的内部类只能被外部类使用<br>&emsp;&emsp;&emsp;<code>外部类的静态成员不能访问非静态内部类</code><br>&emsp;&emsp;&emsp;<code>非静态内部类中不能定义静态成员</code></p>
<h3 id="3-静态成员内部类（被static修饰的内部类）"><a href="#3-静态成员内部类（被static修饰的内部类）" class="headerlink" title="(3) 静态成员内部类（被static修饰的内部类）"></a>(3) 静态成员内部类（被static修饰的内部类）</h3><img src="/2019/07/14/面向对象（三）/p4.jpg" align="left">
<img src="/2019/07/14/面向对象（三）/p5.jpg" align="left">

<p>注意：静态内部类可以包含静态成员，也可以包含非静态成员。<br><code>访问静态内部类中非静态成员首先通过静态内部类的构造器创建静态内部类对象：
new OuterClass.InnerConstructor()</code></p>
<p>内-&gt;外<br><code>静态内部类不能访问外部类的实例成员，只能访问外部类的类成员。</code><br>  <code>静态内部类的实例方法不能访问外部类的实例成员，只能访问外部类的静态成员</code><br>外-&gt;内<br><code>外部类使用静态内部类的类名作为调用者访问静态内部类的类成员</code><br><code>外部类使用静态内部类的对象作为调用者访问静态内部类的实例成员</code></p>
<h3 id="4-局部内部类（在外部类方法中定义类）——只在方法里有效"><a href="#4-局部内部类（在外部类方法中定义类）——只在方法里有效" class="headerlink" title="(4) 局部内部类（在外部类方法中定义类）——只在方法里有效"></a>(4) 局部内部类（在外部类方法中定义类）——只在方法里有效</h3><img src="/2019/07/14/面向对象（三）/p6.jpg" align="left">
`局部内部类只能在其所在的方法中访问`

<p>局部内部类访问局部变量（局部变量最好使用final修饰——局部变量不可再修改）</p>
<pre><code>public void method(){
    final int num = 10;
    class Inner{
        public void print(){
            System.out.println(num);
        }
    }
    Inner i = new Inner();
    i.print();
}</code></pre><h3 id="5-匿名内部类"><a href="#5-匿名内部类" class="headerlink" title="(5) 匿名内部类"></a>(5) 匿名内部类</h3><blockquote>
<p>没有名字的内部类，适合创建只需要一次使用的类——局部内部类的简化写法<br><img src="/2019/07/14/面向对象（三）/p7.jpg" align="left"></p>
</blockquote>
<p>面试题：<br><img src="/2019/07/14/面向对象（三）/p8.jpg" align="left"><br><img src="/2019/07/14/面向对象（三）/p9.jpg" align="left"></p>
<h2 id="四、初始化块（代码块）"><a href="#四、初始化块（代码块）" class="headerlink" title="四、初始化块（代码块）"></a>四、初始化块（代码块）</h2><h3 id="1-语法："><a href="#1-语法：" class="headerlink" title="(1)    语法："></a>(1)    语法：</h3><pre><code>[修饰符]{
//初始化块代码
}</code></pre><p>修饰符：static或缺省</p>
<h3 id="2-作用"><a href="#2-作用" class="headerlink" title="(2)    作用"></a>(2)    作用</h3><p>给对象进行初始化。对象一建立就运行，且优先于构造函数的运行。</p>
<p>与构造函数的区别：<br>非静态初始化块给所有对象进行统一初始化，构造函数只给对应对象初始化。因此在代码块中可以将所有构造函数共性的东西定义与初始化。但代码块不能接收参数。</p>
<h3 id="3-被static修饰的静态代码块"><a href="#3-被static修饰的静态代码块" class="headerlink" title="(3)    被static修饰的静态代码块"></a>(3)    被static修饰的静态代码块</h3><p>给类进行初始化。随着类的加载而执行，且只执行一次</p>
<p>与构造代码块的区别：<br>1）构造代码块用于初始化对象，每创建一个对象就会被执行一次；静态代码块用于初始化类，随着类的加载而执行，不管创建几个对象，都只执行一次。<br>2）静态代码块优先于构造代码块的执行<br>3）都定义在类中，一个带static关键字，一个不带static</p>
<h2 id="五、类中所有成员的执行顺序"><a href="#五、类中所有成员的执行顺序" class="headerlink" title="五、类中所有成员的执行顺序"></a>五、类中所有成员的执行顺序</h2><p>成员变量与代码块谁在前就先执行谁<br>代码块先执行，构造器后执行<br>静态代码块的先执行，非静态代码块的后执行<br>方法与静态方法谁在前就先执行谁（静态方法只能访问静态的成员）</p>
<p>注意：代码块如果在成员变量前，在代码块中如果执行对成员变量的访问，会报非法前向引用错误。这个是由于Java编译器强制进行的一个检查，目的是避免循环初始化和其他非正常的初始化行为。（针对非静态）<br>只有在满足一下4点的情况下，成员变量的声明才必须在使用之前：<br>1.使用出现在类的实例（类）变量初始化，或者类的实例（静态）初始化块中<br>2.使用不在赋值表达式左边<br>3.使用通过简单名称<br>4.类是包含该使用的直接类(接口)</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Hai</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/07/14/面向对象（三）/">http://yoursite.com/2019/07/14/面向对象（三）/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">Hai</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-buttom"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" data-src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" data-src="/img/alipay.jpg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2019/07/14/static与final关键字/"><img class="prev_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>static与final关键字</span></div></a></div><div class="next-post pull-right"><a href="/2019/07/14/面向对象（二）/"><img class="next_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>面向对象（二）</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"></div><div class="clear_both"></div></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By Hai</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><i class="fa fa-book" id="readmode" title="阅读模式"> </i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">簡</a><i class="fa fa-moon-o nightshift" id="nightshift" title="夜间模式"></i></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/nightshift.js"></script><script id="ribbon" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/js/piao.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script></body></html>