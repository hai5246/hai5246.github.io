<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>面向对象（一） | Hai</title><meta name="description" content="面向对象（一）"><meta name="keywords" content><meta name="author" content="Hai"><meta name="copyright" content="Hai"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://yoursite.com/2019/07/13/面向对象（一）/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="面向对象（一）"><meta name="twitter:description" content="面向对象（一）"><meta name="twitter:image" content="http://yoursite.com/img/avatar.png"><meta property="og:type" content="article"><meta property="og:title" content="面向对象（一）"><meta property="og:url" content="http://yoursite.com/2019/07/13/面向对象（一）/"><meta property="og:site_name" content="Hai"><meta property="og:description" content="面向对象（一）"><meta property="og:image" content="http://yoursite.com/img/avatar.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="面向对象（二）" href="http://yoursite.com/2019/07/14/面向对象（二）/"><link rel="next" title="流程控制" href="http://yoursite.com/2019/07/13/流程控制/"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://jerryc.me/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天'

  
}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#面向对象（一）"><span class="toc-number">1.</span> <span class="toc-text">面向对象（一）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、类和对象"><span class="toc-number">1.1.</span> <span class="toc-text">一、类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-定义类-class"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.定义类(class)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-定义成员变量-field"><span class="toc-number">1.1.2.</span> <span class="toc-text">2. 定义成员变量(field)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-定义方法-method"><span class="toc-number">1.1.3.</span> <span class="toc-text">3. 定义方法(method)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-定义构造器-constructor"><span class="toc-number">1.1.4.</span> <span class="toc-text">4. 定义构造器(constructor)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-对象的产生和使用"><span class="toc-number">1.1.5.</span> <span class="toc-text">5. 对象的产生和使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-对象、引用和指针"><span class="toc-number">1.1.6.</span> <span class="toc-text">6. 对象、引用和指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-this-关键字"><span class="toc-number">1.1.7.</span> <span class="toc-text">6. this 关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、方法"><span class="toc-number">1.2.</span> <span class="toc-text">二、方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-定义"><span class="toc-number">1.2.1.</span> <span class="toc-text">1 . 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-属性"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. 属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-参数传递机制"><span class="toc-number">1.2.3.</span> <span class="toc-text">3. 参数传递机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-形参个数可变的方法"><span class="toc-number">1.2.4.</span> <span class="toc-text">4. 形参个数可变的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-递归方法"><span class="toc-number">1.2.5.</span> <span class="toc-text">5. 递归方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-方法重载"><span class="toc-number">1.2.6.</span> <span class="toc-text">6. 方法重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、构造器"><span class="toc-number">1.3.</span> <span class="toc-text">三、构造器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、成员变量和局部变量"><span class="toc-number">1.4.</span> <span class="toc-text">四、成员变量和局部变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-成员变量"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-局部变量"><span class="toc-number">1.4.2.</span> <span class="toc-text">2.局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-成员变量与局部变量的初始化在内存中的运行机制"><span class="toc-number">1.4.3.</span> <span class="toc-text">3. 成员变量与局部变量的初始化在内存中的运行机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-变量使用的规则"><span class="toc-number">1.4.4.</span> <span class="toc-text">4. 变量使用的规则</span></a></li></ol></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/post.png)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">Hai</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><span class="pull-right menus"><div class="mobile_author_icon"><img class="lozad" data-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"><div class="mobile_author-info__description"></div></div><hr><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title"><div class="posttitle">面向对象（一）</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-07-13<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-07-13</time></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="面向对象（一）"><a href="#面向对象（一）" class="headerlink" title="面向对象（一）"></a>面向对象（一）</h1><h2 id="一、类和对象"><a href="#一、类和对象" class="headerlink" title="一、类和对象"></a>一、类和对象</h2><blockquote>
<p>类——是一个模板，描述一类对象的行为和状态<br>对象——是类的一个实例，有状态和行为</p>
</blockquote>
<h3 id="1-定义类-class"><a href="#1-定义类-class" class="headerlink" title="1.定义类(class)"></a>1.定义类(class)</h3><p>(1) 语法：</p>
<blockquote>
<p>&emsp;&emsp;[修饰符] class 类名{<br>    &emsp;&emsp;&emsp;&emsp;零个到多个成员变量<br>    &emsp;&emsp;&emsp;&emsp;零个到多个构造器定义<br>    &emsp;&emsp;&emsp;&emsp;零个到多个方法<br>    &emsp;&emsp;&emsp;&emsp;（零个到多个内部类、枚举、接口）<br>    &emsp;&emsp;&emsp;&emsp;（零个到多个代码块）<br>&emsp;&emsp;}</p>
</blockquote>
<p>修饰符：public、final、abstract或者完全省略(default)<br>类名：合法的标识符（最好是一个或多个有意义的单词连缀而成，驼峰命名法）<br>成员变量：用于定义该类的实例所包含的状态数据<br>构造器：用于创建该类的实例，通过new关键字来调用构造器，从而返回该类的实例<br>方法：用于定义该类或该类的实例的行为特征或者功能实现</p>
<h3 id="2-定义成员变量-field"><a href="#2-定义成员变量-field" class="headerlink" title="2. 定义成员变量(field)"></a>2. 定义成员变量(field)</h3><p>(1) 语法：</p>
<blockquote>
<p>[修饰符] 类型 成员变量名 [=默认值]</p>
</blockquote>
<p>修饰符：可以省略(default)或public、protected、private、static、final，其中public、protected、private    三个最多只能出现一个，可以与static、final组合使用<br>类型：基本数据类型或引用数据类型<br>成员变量名：合法的标识符（最好是一个或多个有意义的单词连缀而成，驼峰命名法）<br>默认值：定义成员变量可以指定一个可选的默认值</p>
<h3 id="3-定义方法-method"><a href="#3-定义方法-method" class="headerlink" title="3. 定义方法(method)"></a>3. 定义方法(method)</h3><p>(1) 语法：</p>
<blockquote>
<p>&emsp;&emsp;[修饰符] 方法返回值类型 方法名(形参列表){<br>&emsp;&emsp;&emsp;&emsp;零条到多条可执行性语句组成的方法体;<br>&emsp;&emsp;&emsp;&emsp;return 返回值;<br>&emsp;&emsp;}</p>
</blockquote>
<p>修饰符：可以省略或public、protected、private、static、final、abstract，其中public、protected、private    三个最多只能出现一个；<code>abstract和final最多只能出现其中之一，final可以与static组合，但abstract不能与static组合。</code><br>方法返回值类型：Java语言允许的任何数据类型，包括基本数据类型和引用    数据类型；如果生命了方法返回值类型，方法体内必须有一个有效的return语句，该语句返回一个变量或一个表达式，且返回的类型必须声明的类型匹配。若没有返回值，必须使用void来声明没有返回值。<br>方法名：合法的标识符（最好是一个或多个有意义的单词连缀而成，驼峰命名法），由于方法用于描述类或实例的行为特征或功能实现，建议方法    名以英文动词开头。<br>形参列表：用于定义该方法可以接受的参数，由零组到多组“参数类型 形参名”组合而成，多组参数之间以英文逗号（,）隔开。<br>返回值：方法结束后的结果，用于把结果返回给调用者。</p>
<h3 id="4-定义构造器-constructor"><a href="#4-定义构造器-constructor" class="headerlink" title="4. 定义构造器(constructor)"></a>4. 定义构造器(constructor)</h3><p>(1) 语法：</p>
<blockquote>
<p>&emsp;&emsp;[修饰符] 构造器名（形参列表）{<br>&emsp;&emsp;&emsp;&emsp;零条到多条可执行性语句组成的构造器执行体<br>&emsp;&emsp;}</p>
</blockquote>
<p>修饰符：可以省略(default)或public、protected、private其中一个<br>构造器名：必须和类名相同<br>形参列表：用于定义该构造器可以接受的参数，由零组到多组“参数类型 形名”组合而成，多组参数之间以英文逗号（,）隔开</p>
<h3 id="5-对象的产生和使用"><a href="#5-对象的产生和使用" class="headerlink" title="5. 对象的产生和使用"></a>5. 对象的产生和使用</h3><p>(1) 产生：<br>&emsp;&emsp;创建对象的根本途径是构造器，通过new关键字来调用某个类的构造器即可创建这个类的对象。<br><code>Java提供了一个功能，如果没有为一个类定义构造器，系统会为该类提供一个默认构造器（无参构造）。一旦提供了构造器，系统将不再提供默认构造器。</code></p>
<p>(2) 使用：<br>① 访问对象的实例变量<br>② 调用对象的方法</p>
<h3 id="6-对象、引用和指针"><a href="#6-对象、引用和指针" class="headerlink" title="6. 对象、引用和指针"></a>6. 对象、引用和指针</h3><p>&emsp;&emsp;对象是多块内存组成，不同内存块分别存储了对象的不同成员变量、方法等。<br>&emsp;&emsp;引用相当于C语言里的指针，但Java把指针封装起来，避免开发者进行繁琐的指针操作。</p>
<p>&emsp;&emsp;Person p = new Person()<br>产生了两个东西：一个是p变量，一个是Person对象<br><code>变量存放在栈内存，对象存放在堆内存</code><br><code>栈内存中的变量p实际是一个引用，指向堆内存中的Person对象</code></p>
<h3 id="6-this-关键字"><a href="#6-this-关键字" class="headerlink" title="6. this 关键字"></a>6. this 关键字</h3><blockquote>
<p>this关键字总是指向调用该方法的对象。（指向本类）<br>代表当前对象的一个引用</p>
</blockquote>
<p>(1) 根据this出现位置的不同，this作为对象的默认引用有两种情形：<br>&emsp;&emsp;1.构造器中引用该构造器正在初始化的对象<br>&emsp;&emsp;2.在方法中引用该方法的对象<br>(2) 缺省this情况<br>(3) 使用情况<br>• 普通方法中使用this。<br>&emsp;&emsp;• 区分类成员属性和方法的形参.<br>&emsp;&emsp;• 调用当前对象的其他方法（可以省略）<br>&emsp;&emsp;• 位置：任意<br>• 构造方法中使用this。<br>&emsp;&emsp;• 使用this来调用其它构造方法<br>&emsp;&emsp;• 位置：必须是第一条语句<br><code>this不能用于static方法</code></p>
<img src="/2019/07/13/面向对象（一）/p1.jpg" align="left">

<h2 id="二、方法"><a href="#二、方法" class="headerlink" title="二、方法"></a>二、方法</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1 . 定义"></a>1 . 定义</h3><blockquote>
<p>完成特定功能的代码块，为了提高代码的复用性</p>
</blockquote>
<h3 id="2-属性"><a href="#2-属性" class="headerlink" title="2. 属性"></a>2. 属性</h3><p>&emsp;&emsp;Java方法不能独立存在，必须属于一个类或对象，因此方法不像C语言的函数被独立执行，执行方法时必须使用类或对象来作为调用者，即所有方法都必须遵循“类.方法”或“对象.方法”的形式来调用。</p>
<h3 id="3-参数传递机制"><a href="#3-参数传递机制" class="headerlink" title="3. 参数传递机制"></a>3. 参数传递机制</h3><p>(1) 形参与实参</p>
<blockquote>
<p>① 形参：全称为“形式参数”是在定义方法名的时候使用的参数，目的是用来接收调用该方法时传递的参数。<br>② 实参：全称为”实际参数”是在调用时传递给方法的参数，即传递给被调用函数的值。</p>
</blockquote>
<p><code>实参传给形参可看做拷贝，基本数据类型拷贝的就是值，所以改了对原来的也没有影响。而引用数据类型拷贝的是地址值，和实参一样指向同一块地址，所以改了值就发生了改变</code></p>
<p>(2) 形参与实参的关系<br>① 形参变量只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。因此，形参只在函数内部有效。函数调用结束返回主调用函数后则不能再使用该形参变量。<br>② 实参可以是常量、变量、表达式、函数等，无论实参是何种类型的量，在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形参。因此应预先用赋值，输入等办法使参数获得确定值。<br>③ 实参和形参在数量上，类型上、顺序上应严格一致，否则就会发生类型不匹配的错误。<br>④ 遵循参数传递机制</p>
<p>(3) 参数传递机制——值传递<br>在传值调用的机制中只能把实参传送给形参，而不能把形参的值反向地传送给实参。<br><code>因此在方法调用过程中，形参值发生改变，而实参中的值不会变化。
 而在引用调用的机制当中是将实参引用的地址传递给了形参，所以任何   发生在形参上的改变实际上也发生在实参变量上。</code><br>将实际参数的副本（复制品）传入方法内，但参数本身不会受到任何影响。</p>
<p>(4) 基本数据类型与引用数据类型的参数传递机制区别<br>基本数据类型的值传递<br><img src="/2019/07/13/面向对象（一）/p2.png" align="left"><br>引用数据类型的值传递<br><img src="/2019/07/13/面向对象（一）/p3.png" align="left"></p>
<h3 id="4-形参个数可变的方法"><a href="#4-形参个数可变的方法" class="headerlink" title="4. 形参个数可变的方法"></a>4. 形参个数可变的方法</h3><p>&emsp;&emsp;在JDK 1.5之后，Java允许定义形参个数可变的参数，从而允许方法指定数量不确定的形参。<br>&emsp;&emsp;在定义方法时，在最后一个形参的类型后增加三点(…)（不是中文省略号），表明该形参可以接受多个参数值，多个参数值被当成数组传入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		dealArray();//</span><br><span class="line">		dealArray(1);//1</span><br><span class="line">		dealArray(1,2,3);//123</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void dealArray(int... intArray) &#123;//intArray是个数组</span><br><span class="line">		for (int i : intArray) &#123;</span><br><span class="line">			System.out.print(i + &quot;&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-递归方法"><a href="#5-递归方法" class="headerlink" title="5. 递归方法"></a>5. 递归方法</h3><blockquote>
<p>一个递归算法必须有两个部分：<br>初始情况和递归部分。<br>&emsp;&emsp;初始情况只处理可以直接解决而不需要再次递归调用的简单输入。<br>&emsp;&emsp;递归部分包含对算法的一次或者多次递归调用</p>
</blockquote>
<p>源自递归算法(一个方法体内调用它自身)</p>
<p>案例：<br>1.阶乘<br><img src="/2019/07/13/面向对象（一）/p4.jpg" align="left"></p>
<p>2.计算<br><img src="/2019/07/13/面向对象（一）/p5.jpg" align="left"></p>
<h3 id="6-方法重载"><a href="#6-方法重载" class="headerlink" title="6. 方法重载"></a>6. 方法重载</h3><blockquote>
<p>同一个类中，方法名相同，但形参列表不同（类型、个数）</p>
</blockquote>
<img src="/2019/07/13/面向对象（一）/p6.png" align="left">

<h2 id="三、构造器"><a href="#三、构造器" class="headerlink" title="三、构造器"></a>三、构造器</h2><p>1 . 作用 ：给对象的属性进行初始化<br>2 . 触发时间：创建对象的时候调用<br>3 . 重载构造器：方法名相同，参数列表不同<br>4 . 无参构造与有参构造<br>&emsp;&emsp;如果没有给出构造方法，系统将自动提供一个无参构造方法。<br>&emsp;&emsp;如果给出了构造方法，系统将不再提供默认的无参构造方法。如果想使用无参构造方法，就必须自己给出。<br><code>最好给出无参构造方法</code></p>
<p>• 构造器是一种特殊的方法：<br>&emsp;&emsp;• 构造器的方法名必须和类名一致！<br>&emsp;&emsp;• 构造器虽然有返回值，但是不能定义返回类型(返回值的类型肯定是本类)，不能在构造器里调用 return。<br>&emsp;&emsp;• 通过new关键字调用！！<br>&emsp;&emsp;• 如果我们没有定义构造器，则系统会自动定义一个无参的构造方法。如果已定义则编译器不会 添加无参数构造方法！<br>&emsp;&emsp;• 与普通方法一样，构造方法也可以重载</p>
<h2 id="四、成员变量和局部变量"><a href="#四、成员变量和局部变量" class="headerlink" title="四、成员变量和局部变量"></a>四、成员变量和局部变量</h2><img src="/2019/07/13/面向对象（一）/p7.png" align="left">

<h3 id="1-成员变量"><a href="#1-成员变量" class="headerlink" title="1.成员变量"></a>1.成员变量</h3><p>&emsp;&emsp;(1) 类变量和实例变量统称为成员变量。其中类变量可以理解为类成员变量，它作为类本身的一个成员，与类本身共存亡；实例变量则可以理解为实例成员变量，它作为实例的一个成员与实例共存亡。<br>&emsp;&emsp;①.类变量从该类的准备阶段起开始存在，直到系统完全销毁这个类，类变量的作用域与这个类的生存范围相同。只要类存在,类就可以访问类变量(类.类变量)<br>&emsp;&emsp;②.实例变量则从该类的实例被创建起开始存在，直到系统完全销毁这个实例，实例变量的作用域与对应实例的生存范围相同。只要实例存在，实例就可以访问实例变量(实例.实例变量)<br>&emsp;&emsp;实例也可以访问类变量。但是需要注意的是因为实例不拥有类变量，所以通过实例来访问类变量进行操作，实际上是对类变量进行操作，当有其他实例来访问类变量时，访问的类变量是被对象访问操作过的类变量。</p>
<p>&emsp;&emsp;(2) <code>成员变量无需显示初始化</code>，只要为一个类定义了类变量或实例变量，系统就会在这个类的准备阶段或创建该类的实例时进行默认初始化。</p>
<h3 id="2-局部变量"><a href="#2-局部变量" class="headerlink" title="2.局部变量"></a>2.局部变量</h3><p>局部变量根据定义形式的不同，又可以分为如下三种：<br>(1) 形参：在定义方法签名时定义的变量，形参的作用域在整个方法中都有效<br>(2) 方法局部变量：在方法体内定义的局部变量，它的作用域是从定义该变量的地方生效，到该方法结束时失效<br>(3) 代码块局部变量：这个局部变量的作用域从定义该变量的地方生效，到该代码结束时失效。</p>
<p>&emsp;&emsp;java允许局部变量和成员变量同名，如果方法中局部变量和成员变量同名，局部变量就会覆盖成员变量，如果需要在这个方法中引用被覆盖成员变量，则可使用this（对于实例变量）或类名（对于类变量）作为调用者来限定访问成员变量。</p>
<h3 id="3-成员变量与局部变量的初始化在内存中的运行机制"><a href="#3-成员变量与局部变量的初始化在内存中的运行机制" class="headerlink" title="3. 成员变量与局部变量的初始化在内存中的运行机制"></a>3. 成员变量与局部变量的初始化在内存中的运行机制</h3><p>成员变量：<br>当系统加载类或者创建类的实例时，此时系统便自动为成员变量分配空间，并在分配空间后自动为成员变量指定初始化值</p>
<p>局部变量：<br>局部变量必须经过显示初始化之后才能使用，系统不会为局部变量执行初始化。定义了局部变量以后，系统并没有给局部变量进行初始化，直到程序给这个局部变量赋给初值时，系统才会为这个局部变量分配内存空间，并将初始值保存到这块内存中。</p>
<p>局部变量与成员变量不同，它不属于任何类或者实例，因此总是保存在其所在的方法的栈内存中。另外，<code>栈内存中的变量无需系统垃圾回收，往往随方法或代码块的运行结束而结束。</code>因此局部变量的范围是从初始化该变量开始的，知道该方法或该代码块运行完成而结束，同时它占用的内存区通常较小。<br>链接：<a href="https://www.jianshu.com/p/62c82e886388" target="_blank" rel="noopener">https://www.jianshu.com/p/62c82e886388</a></p>
<h3 id="4-变量使用的规则"><a href="#4-变量使用的规则" class="headerlink" title="4. 变量使用的规则"></a>4. 变量使用的规则</h3><p>(1) 成员变量的弊端<br>&emsp;&emsp;定义成员变量时，成员变量将被放置在堆内存中，成员变量的作用域将扩大到类存在范围或者对象存在范围，这种范围的扩大有两个弊端：<br>&emsp;&emsp;①增大了变量的生存时间，这将导致更大的内存开销<br>&emsp;&emsp;②扩大了变量的作用域，这不利于提高程序的内聚性<br>(2) 以下情况使用成员变量<br>&emsp;&emsp;①如果需要定义的变量是用于描述某个类或某个对象的固有属性信息，例如人的身高、体重等信息，这种变量应该定义为成员变量。<br>如果类的所有实例都有这种固有属性信息的值完全相同，则定义为类变量；如果每个实例的固有属性信息的值不完全相同，则定义为实例变量。<br>&emsp;&emsp;②如果在某个类中需要一个变量来保存类或实例运行时的状态信息，则使用成员变量。<br>&emsp;&emsp;③如果某个信息需要在某个类中的多个方法之间进行共享，则使用成员变量。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Hai</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/07/13/面向对象（一）/">http://yoursite.com/2019/07/13/面向对象（一）/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">Hai</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-buttom"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" data-src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" data-src="/img/alipay.jpg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2019/07/14/面向对象（二）/"><img class="prev_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>面向对象（二）</span></div></a></div><div class="next-post pull-right"><a href="/2019/07/13/流程控制/"><img class="next_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>流程控制</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"></div><div class="clear_both"></div></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By Hai</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><i class="fa fa-book" id="readmode" title="阅读模式"> </i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">簡</a><i class="fa fa-moon-o nightshift" id="nightshift" title="夜间模式"></i></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/nightshift.js"></script><script id="ribbon" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/js/piao.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script></body></html>